class AStar(object): #Class that run the A Star Algorithm
    def __init__(self, cities, start, stop = "Bucharest"):
        self.start = start      #The name of the first/start city
        self.cities = cities    #List of cities from the JSON file 'cities.json'
        self.stop = stop        #The name of the last/stop city
        self.frontier = []      #Holder of all the frontiers

    def generateState(self, state):     #Recive the current state

        city = self.getCity(state.name) #Get the city of the state
        new_states = []                 #List of all new states
        for i in range(len(city["adjacent_cities"])):   #Run on the list of adjancent cities of the current state
            new_city = self.getCity(city["adjacent_cities"][i]["name"]) #Get the new city

            if new_city["name"] not in state.path:
                # Append the new city to the list os sas a state
                new_states.append(State(new_city["name"],
                                        city["adjacent_cities"][i]["dist"] + state.fg,
                                        new_city["dist_to_bucharest"], state.path))
        return new_states #Return the list

    def addToFrontier(self, list_of_new_states): #Add states in an orderly manner to the frontier
        # If is the first state and the frontier is not empty, remode the first state
        if len(self.frontier) > 0 and self.frontier[0].name == self.start:
            self.frontier.pop(0)
        self.frontier.extend(list_of_new_states) #Extend  the frontier with the nes states
        # Order the frontier to the first be always the node with the smallest F (n)
        self.frontier.sort(key=lambda x: x.fn)
        self.printFrontier(self.frontier)   #Print the frontier

    def getCity(self,name): #Get the City by the name from the "cities.json" file
        try:
            for i in range(len(self.cities["cities"])):
                if self.cities["cities"][i]["name"] == name:
                    return self.cities["cities"][i]
            return None
        except:
            return None

    def printFrontier(self, frontier):       #Print the Frontier with ' | ' in between the nodes
        for i in frontier:
            print(" | {0}".format(i), end="")
        print("\n")

    def printPath(self, path):              #Print the Frontier with ' => ' in between the nodes
        print( " => ".join(path))

    def getPath(self):                              #Generate the path from the start city to the stop city "Bucharest"
        city = self.getCity(self.start)             #Get the first city
        if city:                                    #If the city exist, run the path finder
            state = State(city["name"], 0, city["dist_to_bucharest"]) #Turn the city into a State
            self.addToFrontier([state])  #Add the state to the frontier
            # While the current state/city is not the stop/aim city keep searching
            while state.name != self.stop and len(self.frontier) > 0:
                list_of_new_states = self.generateState(state)      #Generates the new states of the current city
                # Add the generated list of states to the frontier in an orderly manner
                self.addToFrontier(list_of_new_states)
                # Change the current state to the first of the frontiers and remove it from the frontier
                state = self.frontier.pop(0)

            return state.path                   #Return only the path from the start to the stop city
        else:           #If the city does not exist return None to the path
            return None

class State(object): #Class that hold the state to the tree generated by the A Star Algorithm
    def __init__(self, name, fg, fh, path = []): #If it is the first state it will not get the path of the parent
        self.name = name        #The name of the city
        self.fg = fg            #The f(g) value of the state
        self.fh = fh            #The f(h) value of the state from the heuristic used
        self.fn = self.fg + self.fh  #The f(n) value of the state calculated by "f(n) = f(g) + f(h)"
        self.path = path[:]     #Copy path os the parent state
        self.path.append(name)  #Add itself to the path

    def __str__(self):
        return "City: " +self.name + " F(n):" + str(self.fn) #print the State name and f(n)